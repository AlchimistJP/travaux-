# -*- coding: utf-8 -*-
"""-tp_2_wuleme_komivi_jean-paul.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/AlchimistJPaul/53e6145d2bd6eb43c58ec8cb10750a1a/-tp_2_wuleme_komivi_jean-paul.ipynb

Ce projet vise à analyser et prédire le niveau de stress des individus en se basant sur différentes caractéristiques telles que la durée et la qualité du sommeil, le niveau d'activité physique, la catégorie d'IMC, la pression artérielle, etc. Voici un résumé des données utilisées et des principales caractéristiques de l'ensemble de données :

- **Données utilisées**: L'ensemble de données comprend des informations sur 373 individus, avec 13 colonnes couvrant un large éventail de variables liées au sommeil, à la santé et aux habitudes de vie.

- **Principales caractéristiques**:
  1. **Mesures complètes du sommeil**: Durée et qualité du sommeil, ainsi que les facteurs influençant les habitudes de sommeil.
  2. **Facteurs de mode de vie**: Analyse des niveaux d'activité physique, des niveaux de stress et des catégories d'IMC.
  3. **Santé cardiovasculaire**: Examens des mesures de la tension artérielle et de la fréquence cardiaque.
  4. **Analyse des troubles du sommeil**: Identification des troubles du sommeil tels que l'insomnie et l'apnée du sommeil.

- **Colonnes de l'ensemble de données**:
  1. Person ID: Identifiant unique pour chaque individu.
  2. Gender: Sexe de la personne.
  3. Age: Âge de la personne en années.
  4. Occupation: Profession ou occupation de la personne.
  5. Sleep Duration (hours): Durée du sommeil par jour.
  6. Quality of Sleep (scale: 1-10): Évaluation subjective de la qualité du sommeil.
  7. Physical Activity Level (minutes/day): Durée de l'activité physique par jour.
  8. Stress Level (scale: 1-10): Évaluation subjective du niveau de stress.
  9. BMI Category: Catégorie d'Indice de Masse Corporelle (IMC) de la personne.
  10. Blood Pressure (systolic/diastolic): Mesure de la pression artérielle.
  11. Heart Rate (bpm): Fréquence cardiaque au repos.
  12. Daily Steps: Nombre de pas effectués par jour.
  13. Sleep Disorder: Présence ou absence de troubles du sommeil tels que l'insomnie et l'apnée du sommeil.

Les détails de la colonne "Sleep Disorder" indiquent la présence ou l'absence de troubles du sommeil spécifiques tels que l'insomnie et l'apnée du sommeil, ce qui fournit des informations supplémentaires pour l'analyse.

Ce projet permettra d'explorer les relations entre ces variables et de développer des modèles de prédiction du niveau de stress des individus en fonction de leurs caractéristiques de sommeil, de santé et de mode de vie.

## Partie I :  Exploration de donne
Nous allons importer la donnees qui es un fichier csv ensuite les les bibliotheques telque pandas , seaborn, matplotlib pour faire exploration des donnees
"""
import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# importation du fichier csv pour l'exploration
data = pd.read_csv("Sleep_health_and_lifestyle_dataset.csv")
print('data', data.shape)  # data.shape pour voir le nombre de ligne et de colonne dans le dataframe

# nous avons constater que le le nombre de ligne est egal a 374 et le nombre de colonne 13
# A present nous allons explore la donnee  pour voir comment les donner ce presente
print(data.head(10))
data.tail()

"""Nous constatons qu'il as de doublons dans le dataframe
pour mieux suprimer les doublons nous allons suprimer la colomns person ID
"""

data1 = data.copy()
data1.head()

if 'Person ID' in data1.columns:
    # Drop 'Person ID' column
    data1.drop(columns='Person ID', inplace=True)

data1.head()
st.write(data1)
# Verifions les doublons
data1.duplicated().sum()

data1.drop_duplicates(inplace=True)

data1.duplicated().sum()

data1.head()

# verifions s'il y a des donner nul dans le dataframe
data1.isnull().sum()

data1["Sleep Disorder"].value_counts(dropna=False)

data1["Stress Level"].value_counts(dropna=False)

data1['Sleep Disorder'].fillna('aucun', inplace=True)

data1.isnull().sum()

# Il n y a pas de donnee nulle ni de donnee manquante
# verifions les types de colonnes
data1.dtypes

"""Les variables numériques de notre DataFrame sont :
- Age
- Sleep Duration
- Physical Activity Level
- Stress Level
- Heart Rate
- Daily Steps

Les variables catégorielles sont :
- Sleep Disorder
- Gender
- BMI Category
- Blood Pressure
- Occupation

Les donner ainsi cindérer nous permettra de faire une bonne visualisation des données avec des graphiques tels que des histogrammes et des boxplots pour visualiser les distributions ou les relations entre les variables.
Nous allons faire des visualisation pour mieux comprendres le codes
"""

# faisons le describe sur le dataframe pour voir les means, std des variables numerique
data1.describe()

# Créer un box plot du niveau de stress par gendre
plt.figure(figsize=(10, 6))
sns.boxplot(x='Gender', y='Stress Level', data=data1, palette='Set2')
plt.title('Distribution du niveau de stress par Gender')
plt.xlabel('Gender')
plt.ylabel('Niveau de stress')
plt.grid(True)
plt.xticks(rotation=45)
plt.show()

"""# Nous constatons que les hommes sont plus stress que les femmes."""

# Créer un box plot du niveau de stress par groupe d'âge
plt.figure(figsize=(10, 6))
sns.boxplot(y='Age', x='Stress Level', data=data1, palette='Set2')
plt.title('Distribution du niveau de stress par groupe d\'âge')
plt.ylabel('Age')
plt.xlabel('Niveau de stress')
plt.grid(True)
plt.xticks(rotation=45)
plt.show()

"""- Les hommes de 53 ans a 60 ans sont moins stress
- Les hommes de 28 ans a 50 ans ont une stress qui varie de 4 a 8
"""

# Créer un box plot du niveau de stress par duree de sommeil
plt.figure(figsize=(10, 6))
sns.boxplot(y='Sleep Duration', x='Stress Level', data=data1, palette='Set2')
plt.title('Distribution du niveau de stress par a duree du sommeil')
plt.ylabel('Sleep Duration')
plt.xlabel('Niveau de stress')
plt.grid(True)
plt.xticks(rotation=45)
plt.show()

"""Ceux qui dorment moins sont souvent tres stress."""

# Créer un box plot du niveau de stress par occupation
plt.figure(figsize=(10, 6))
sns.boxplot(x='Occupation', y='Stress Level', data=data1, palette='Set2')
plt.title('Distribution du niveau de stress par a l occupation')
plt.xlabel('Occupation')
plt.ylabel('Niveau de stress')
plt.grid(True)
plt.xticks(rotation=45)
plt.show()

"""le niveau de stress depend du metier"""

# Créer un box plot du niveau de stress par masse d indice corporelle
plt.figure(figsize=(10, 6))
sns.boxplot(x='BMI Category', y='Stress Level', data=data1, palette='Set2')
plt.title('Distribution du niveau de stress par Indice de Masse Corporelle (IMC))')
plt.xlabel('BIM Caterory')
plt.ylabel('Niveau de stress')
plt.grid(True)
plt.xticks(rotation=45)
plt.show()

"""les obeses sont plus stress"""

# Créer un box plot du niveau de stress par sleep disorder
plt.figure(figsize=(10, 6))
sns.boxplot(x='Sleep Disorder', y='Stress Level', data=data1, palette='Set2')
plt.title('Distribution du niveau de stress par Disorder')
plt.xlabel('BIM Caterory')
plt.ylabel('Niveau de stress')
plt.grid(True)
plt.xticks(rotation=45)
plt.show()

sns.boxplot(x='Stress Level', y='Physical Activity Level', data=data1, palette='Set2')
plt.show()

sns.boxplot(x='Sleep Disorder', y='Physical Activity Level', data=data1)
plt.show()

# Corrélation entre les variables
numericals = ['Age', 'Sleep Duration', 'Physical Activity Level', 'Stress Level', 'Heart Rate', 'Daily Steps']
numerical = data1[numericals]
correlation_matrix = numerical.corr()
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.show()

"""## Partie II : Model de predilection
Dans ce script, nous avons utilisé une régression linéaire pour modéliser la relation entre les caractéristiques (variables indépendantes) et le niveau de stress (variable cible). Voici une introduction et une explication des calculs a effectués :

1. **Introduction** :
   - Nous avons divisé nos données en ensembles d'entraînement et de test pour évaluer les performances du modèle sur des données non vues.
   - Nous avons utilisé l'encodage one-hot pour transformer nos variables catégorielles en variables binaires, ce qui permet au modèle de les utiliser dans l'analyse.

2. **Entraînement du modèle** :
   - Nous avons initialisé un modèle de regression logistique, modèle ANN et modele knn.
   - Nous avons entraîné le modèle en ajustant les coefficients des caractéristiques aux valeurs de la variable cible dans l'ensemble d'entraînement.


Après avoir entraîné le modèle et effectué des prédictions sur l'ensemble de test, nous pouvons ajouter une évaluation supplémentaire en comparant les prédictions avec les valeurs réelles de la variable cible.


"""

# Séparation des variables catégorielles et numériques
categorical_cols = [var for var in data1.columns if data1[var].dtype == 'O']
numerical_cols = [var for var in data1.columns if var != 'Stress Level' and var not in categorical_cols]

# Afficher le nombre de variables catégorielles et numériques
print("Nombre de variables catégorielles:", len(categorical_cols))
print("Nombre de variables numériques:", len(numerical_cols))

# Encoder et Ajouter les colonnes de variables factices
data1 = pd.get_dummies(data1, columns=['Gender', 'Occupation', 'BMI Category', 'Sleep Disorder', "Blood Pressure"],
                       drop_first=True)

data1.dtypes

data1.head()

from sklearn.preprocessing import LabelEncoder

# Initialisez l'encodeur d'étiquettes
label_encoder = LabelEncoder()

# Normalisation des variables numéric

from sklearn.preprocessing import StandardScaler

# Normalisation des variables numériques
scaler = StandardScaler()
data1[numerical_cols] = scaler.fit_transform(data1[numerical_cols])

data1.head()

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
X = data1.drop(['Stress Level'], axis=1).values
y = data1['Stress Level']
# Diviser les données en ensembles d'entraînement et de test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialiser le modèle de régression logistique
logistic_reg = LogisticRegression(max_iter=1000)

# Ajuster le modèle aux données d'entraînement
logistic_reg.fit(X_train, y_train)

# Faire des prédictions sur l'ensemble de test
y_pred_lo = logistic_reg.predict(X_test)

# Évaluer le modèle
from sklearn.metrics import accuracy_score

accuracy0 = accuracy_score(y_test, y_pred_lo)
print("Accuracy:", accuracy0)

from sklearn.metrics import classification_report, confusion_matrix

# Afficher le rapport de classification
print("Rapport de classification pour la régression logistique:")
print(classification_report(y_test, y_pred_lo))

# Afficher la matrice de confusion
cm_logistic = confusion_matrix(y_test, y_pred_lo)
print("Matrice de confusion pour la régression logistique:")
print(cm_logistic)

from sklearn.metrics import mean_squared_error

# Calculer l'erreur quadratique moyenne
mse = mean_squared_error(y_test, y_pred_lo)
print("Mean Squared Error:", mse)

from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import accuracy_score

# Diviser les données en ensembles d'entraînement et de test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialiser le modèle ANN (perceptron multicouche)
ann_model = MLPClassifier(hidden_layer_sizes=(100,), activation='relu', solver='adam', max_iter=1000)

# Ajuster le modèle aux données d'entraînement
ann_model.fit(X_train, y_train)

# Faire des prédictions sur l'ensemble de test
y_pred_ann = ann_model.predict(X_test)

# Évaluer le modèle
accuracy1 = accuracy_score(y_test, y_pred_ann)
print("Accuracy:", accuracy1)

# Faire des prédictions sur l'ensemble de test
y_pred_ann = ann_model.predict(X_test)

# Afficher le rapport de classification
print("Rapport de classification pour le réseau de neurones artificiels:")
print(classification_report(y_test, y_pred_ann))

# Afficher la matrice de confusion
cm_ann = confusion_matrix(y_test, y_pred_ann)
print("Matrice de confusion pour le réseau de neurones artificiels:")
print(cm_ann)

from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

# Diviser les données en ensembles d'entraînement et de test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialiser le modèle KNN avec k=5 voisins (vous pouvez ajuster k selon vos besoins)
knn_model = KNeighborsClassifier(n_neighbors=5)

# Ajuster le modèle aux données d'entraînement
knn_model.fit(X_train, y_train)

# Faire des prédictions sur l'ensemble de test
y_pred_knn = knn_model.predict(X_test)

# Évaluer le modèle
accuracy2 = accuracy_score(y_test, y_pred_knn)
print("Accuracy:", accuracy2)

# Faire des prédictions sur l'ensemble de test
y_pred_knn = knn_model.predict(X_test)

# Afficher le rapport de classification
print("Rapport de classification pour KNN:")
print(classification_report(y_test, y_pred_knn))

# Afficher la matrice de confusion
cm_knn = confusion_matrix(y_test, y_pred_knn)
print("Matrice de confusion pour KNN:")
print(cm_knn)


"""
En conclusion, après avoir évalué les performances des trois modèles (régression logistique, réseau de neurones artificiels et K plus proches voisins) sur notre ensemble de données, nous constatons que le modèle KNN (K plus proches voisins) présente la plus haute précision (accuracy) parmi les trois. Cela signifie que le modèle KNN est capable de prédire avec une plus grande exactitude le niveau de stress des individus en se basant sur les caractéristiques fournies dans les données.

"""